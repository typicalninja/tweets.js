<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: client.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/nav.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.3/fuse.min.js"></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link type="text/css" rel="stylesheet" href="styles/skyceil.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css">
</head>

<body>

<nav class="navbar">
    <div class="utilities">
        <div id="search">
            <input type="text" id="search-box" placeholder="Search"><br>
            <div id="search-results" style="display: none;"></div>
        </div>
        <button class="theme" data-theme="light"><i class="fas fa-moon"></i></button>
    </div>
    <hr>
    <h4><a href="index.html">Home</a></h4><h5 class="no-bottom must-underline">Classes</h5><ul><li><span class="small-icon C">C</span><b><a href="client.html">client</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="client.html#disconnect">disconnect</a></li><li><span class="small-icon F">F</span><a href="client.html#follow">follow</a></li><li><span class="small-icon F">F</span><a href="client.html#get">get</a></li><li><span class="small-icon F">F</span><a href="client.html#getFollowers">getFollowers</a></li><li><span class="small-icon F">F</span><a href="client.html#getTweets">getTweets</a></li><li><span class="small-icon F">F</span><a href="client.html#getUser">getUser</a></li><li><span class="small-icon F">F</span><a href="client.html#post">post</a></li><li><span class="small-icon F">F</span><a href="client.html#reconnect">reconnect</a></li><li><span class="small-icon F">F</span><a href="client.html#reply">reply</a></li><li><span class="small-icon F">F</span><a href="client.html#retweet">retweet</a></li><li><span class="small-icon F">F</span><a href="client.html#searchUsers">searchUsers</a></li><li><span class="small-icon F">F</span><a href="client.html#start">start</a></li><li><span class="small-icon F">F</span><a href="client.html#thread">thread</a></li><li><span class="small-icon F">F</span><a href="client.html#tweet">tweet</a></li><li><span class="small-icon F">F</span><a href="client.html#unfollow">unfollow</a></li><li><span class="small-icon F">F</span><a href="client.html#uploadMedia">uploadMedia</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="deletedTweet.html">deletedTweet</a></b><ul class="has-class-methods"><li><span class="small-icon M">M</span><a href="deletedTweet.html#deleted">deleted</a></li><li><span class="small-icon M">M</span><a href="deletedTweet.html#id">id</a></li><li><span class="small-icon M">M</span><a href="deletedTweet.html#raw">raw</a></li><li><span class="small-icon M">M</span><a href="deletedTweet.html#user">user</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="tweet.html">tweet</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="tweet.html#reply">reply</a></li><li><span class="small-icon F">F</span><a href="tweet.html#retweet">retweet</a></li><li><span class="small-icon M">M</span><a href="tweet.html#client">client</a></li><li><span class="small-icon M">M</span><a href="tweet.html#content">content</a></li><li><span class="small-icon M">M</span><a href="tweet.html#createdAt">createdAt</a></li><li><span class="small-icon M">M</span><a href="tweet.html#id">id</a></li><li><span class="small-icon M">M</span><a href="tweet.html#raw">raw</a></li><li><span class="small-icon M">M</span><a href="tweet.html#replyTo">replyTo</a></li><li><span class="small-icon M">M</span><a href="tweet.html#request">request</a></li><li><span class="small-icon M">M</span><a href="tweet.html#retweets">retweets</a></li><li><span class="small-icon M">M</span><a href="tweet.html#user">user</a></li></ul></li><li><span class="small-icon C">C</span><b><a href="User.html">User</a></b><ul class="has-class-methods"><li><span class="small-icon F">F</span><a href="User.html#follow">follow</a></li><li><span class="small-icon F">F</span><a href="User.html#getFollowers">getFollowers</a></li><li><span class="small-icon F">F</span><a href="User.html#unfollow">unfollow</a></li><li><span class="small-icon M">M</span><a href="User.html#createdAt">createdAt</a></li><li><span class="small-icon M">M</span><a href="User.html#following">following</a></li><li><span class="small-icon M">M</span><a href="User.html#id">id</a></li><li><span class="small-icon M">M</span><a href="User.html#likedPosts">likedPosts</a></li><li><span class="small-icon M">M</span><a href="User.html#name">name</a></li><li><span class="small-icon M">M</span><a href="User.html#profileURL">profileURL</a></li><li><span class="small-icon M">M</span><a href="User.html#raw">raw</a></li><li><span class="small-icon M">M</span><a href="User.html#screenName">screenName</a></li></ul></li></ul><h5 class="no-bottom must-underline">Events</h5><ul><li><span class="small-icon E">E</span><a href="client.html#event:ping">ping</a></li><li><span class="small-icon E">E</span><a href="client.html#event:raw">raw</a></li><li><span class="small-icon E">E</span><a href="client.html#event:ready">ready</a></li><li><span class="small-icon E">E</span><a href="client.html#event:reconnect">reconnect</a></li><li><span class="small-icon E">E</span><a href="client.html#event:tweet">tweet</a></li><li><span class="small-icon E">E</span><a href="client.html#event:tweetDelete">tweetDelete</a></li><li><span class="small-icon E">E</span><a href="client.html#event:warning">warning</a></li></ul><h4><a href="global.html">Global</a></h4>
</nav>

<div id="main">
    <div class="burger">
        <div class="burger-line-1"></div>
        <div class="burger-line-2"></div>
        <div class="burger-line-3"></div>
    </div>

    <h1 class="page-title">Source: client.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const constants = require('./utils/constants');
const Func = require('./utils/functions.js');
const querystring = require("querystring");
const EventEmitter = require('events');
const sm = require('./streamManager');
const wait = require('util').promisify(setTimeout);
// request client
const fetch = require('node-fetch');

// Internal Structures
const tweet = require('./struc/tweet.js');
const User = require('./struc/user');
const deletedTweet = require('./struc/deletedTweet.js');

/**
 * The core client
 * @class
 * @param {ClientOptions} Options - Options for tweets.js client
 */
class client extends EventEmitter {
    constructor(options = {}) {
      super();
        if(!options || typeof options !== 'object') throw new Error('Options not provided');
        // the raw options provided by the user
        this._RawOptions = options;
// the merged options
        const config = Object.assign({}, constants.DefaultOptions, options);
        this._options = Object.freeze(config);
        this.streamData = {};
        if(this._options.emitter) this.streamData.indefinite = true;
        if(this._options.emitterUrl) this.streamData.streamUrl = this._options.emitterUrl;
        if(this._options.autoReconnect) this.streamData.reconnect = this._options.autoReconnect;
        // set the version for future use
        this.version = config.version == '1.1' ? '1' : '2';
        // Set the auth type for restricting function to certain types
         /**
         * The type this client has authenticated as
         * @type {String}
         * @private
         */
        this.authenticationType = config.bearer_token ? 'APP' : 'USER';
 // create the main internal oauth client
        this._client = Func.createClient(config.consumer_key, config.consumer_secret);
// get the base url
        this.BaseUrl = Func.getUrl(config.subdomain, config.version);
        this.uploadUrl = Func.getUrl('upload', config.version);

        if(this.authenticationType === 'USER') {
           /**
         * User data
         * @type {String}
         * @private
         */
          this._UserData = {
            key: this._options.access_token,
            secret: this._options.access_token_secret,
          };
        }

        if(this._options.verifyCredentials) {
          this.verifyCredentials().then((r) => {
                  this.user = new User(r, this);
            }).catch(() => {
              throw new Error('Credentials invalid');
            });
        }

        this.stream = null;

        this.pingTimeout = null;
    }
    /**
   * Build all the data required to be sent to twitter
   * @param {string} method - 'GET' or 'POST'
   * @param {string} path - the API endpoint
   * @param {object} parameters - request parameters
   * @private
   */
    _buildRequest(method, path, parameters) {
        const Data = {
            url: `${constants.upload_ends.includes(path) ? this.uploadUrl : this.BaseUrl}/${path}${this.version == '1' ? '.json' : ''}`,
            method: method,
          };

        if (parameters) {
            if (method === 'POST') Data.data = parameters;
            else Data.url += '?' + querystring.stringify(parameters);
        }
  
        let headers = {};
        if (this.authenticationType === 'USER') {
          headers =  this._client.toHeader(
            this._client.authorize(Data, this._UserData),
          );
        } else {
          headers = {
            Authorization: `Bearer ${this._options.bearer_token}`,
          };
        }
        return {
          Data,
          headers,
        };

    }
      /**
   * Handle the returned response from the fetch request
   * @param {Response} response -   Returned response
   * @private
   */
    async _handleResponse(resp) {
      const headers = resp.headers;

      if (resp.ok) {
        // Return empty response on 204 , or content-length = 0
        if (resp.status === 204 || resp.headers.get('content-length') === '0')
          return {
            _headers: headers,
          };
        // Otherwise, parse JSON response
        return resp.json().then(res => {
          res._headers = headers;
          return res;
        });
      } else {
        throw {
          _headers: headers,
          ...await resp.json(),
        };
      }
    }
     /**
   * Send a GET request
   * @param {string} path - endpoint, e.g. `followers/ids`
   * @param {object} [parameters] - optional parameters
   */
    get(path, parameters) {
      const reqData = this._buildRequest(
        'GET',
        path,
        parameters,
      );
  const headers = Object.assign({}, constants.BASE_GET_HEADERS, reqData.headers);
      return fetch(reqData.Data.url, { headers: headers }).then(this._handleResponse);
    }
    // https://github.com/draftbit/twitter-lite/blob/master/twitter.js#L40
    /**
   * Send a post request
   * @param {string} path - endpoint, e.g. `followers/ids`
   * @param {object} [parameters] - optional parameters
   */
    post(path, parameters) {
      const reqData = this._buildRequest(
        'POST',
        path,
        constants.JSON_ENDPOINTS.includes(path) ? null : parameters, // don't sign JSON bodies; only parameters
      );

      const Headers = Object.assign({}, constants.BASE_HEADERS, reqData.headers);

      if (constants.JSON_ENDPOINTS.includes(path)) {
        parameters = JSON.stringify(parameters);
      } else {
        parameters = Func.percentEncode(querystring.stringify(parameters));
        Headers['Content-Type'] = 'application/x-www-form-urlencoded';
      }

    return fetch(reqData.Data.url, { method: 'POST', headers: Headers, body: parameters }).then(this._handleResponse);
    }

  /**
   * post a tweet
   * @param {string} message - tweet to post
   * @param {object} options - tweet options
   * @param {object} options.body - additional body with the constructed body
   * @returns {tweet}
   */
   async tweet(message, options = {}) {
     if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a user type to tweet, got "${this.authenticationType}"`);
        if(!message) throw new Error('Cannot tweet a empty message');
        if(options &amp;&amp; typeof options !== 'object') throw new Error('Options must be a object');
        const body = {
          status: message,
        };
// add user provided body to original body
        if(options.body &amp;&amp; typeof options.body == 'object') {
          const keys = Object.keys(options.body);
          keys.forEach((key) => {
            body[key] = options.body[key];
          });
        }
      const request = await this.post('statuses/update', body);
      return new tweet(request, this);
   }

     /**
   * gets a tweet
   * @param {Array} tweetIds - Array of tweet ids to get
   * @param {object} options - method options
   * @param {object} options.include_entities - The entities node that may appear within embedded statuses will not be included when set to false.	
   * @return {Array&lt;tweet>}
   */
   async getTweets(tweetIds = [], options = {}) {
      if(!Array.isArray(tweetIds)) throw new Error('tweet ids must be a array');
      const joinedArray = tweetIds.join(',');

      const parameters = {
             id: joinedArray,
      };

      if(options.include_entities) parameters.include_entities = options.include_entities;

      const request = await this.get('statuses/lookup', parameters);

     if(request.length &lt;= 0) throw new Error('Did not find any tweets with the specified tweetIds');
const tweets = [];
     for (const tweet_X of request) {
       if(tweet_X.id) {
    const constructed = new tweet(tweet_X, this);
    tweets.push(constructed);
       }
     }
     return tweets;
   }

   /**
   * reply to a tweet
   * @param {string} message - tweet to post
   * @param {string} to - Id of the tweet to reply
   * @param {object} options - options for reply()
   * @param {object} options.body - additional body with the constructed body
   * @returns {tweet}
   */
   async reply(message, to, options = {}) {
     if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a user type to tweet/reply, got "${this.authenticationType}"`);
     if(!to) throw new Error(`Need a tweet id to reply to`);
     if(!message) throw new Error('Cannot reply with a empty message');
     if(options &amp;&amp; typeof options !== 'object') throw new Error('Options must be a object');

     const body = {
      status: message,
      in_reply_to_status_id: to,
      auto_populate_reply_metadata: true,
    };

    if(options.body &amp;&amp; typeof options.body == 'object') {
      const keys = Object.keys(options.body);
      keys.forEach((key) => {
        body[key] = options.body[key];
      });
    }

    const request = await this.post('statuses/update', body);
    return new tweet(request, this);
   }

     /**
   * Make a thread
   * @param {Array&lt;any>} threadMessages - Array of messages to make a thread out of
   * @param {Object} options - options for either reply() or tweet()
   * @param {String} options.lastTweetID - starting the thread with already posted tweet?
   * @param {String} options.delay - add a delay to in how many time it should take to post it tweet, default to 10000
   * @return {Promise&lt;tweet[]>}
   */
   async thread(threadMessages = [], options = {}) {
    if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a User, got "${this.authenticationType}"`);
     if(!threadMessages) throw new Error('Cannot create a empty thread');
     if(!Array.isArray(threadMessages)) throw new Error(`threadMessages Must be a array got "${typeof threadMessages}"`);
     if(options.functionOptions &amp;&amp; typeof options.functionOptions !== 'object') throw new Error(`functionOptions must be a object. got ${typeof options.functionOptions}`);

     // keep track of the last tweet posted
     let lastTweetID = options.lastTweetID || null;
     // make a empty array to be returned later with all the thread tweets classes
     const threads = [];
     for (const message of threadMessages) {
       // Add a delay to stop getting rate limited
       if(options.delay &amp;&amp; isNaN(parseInt(options.delay)) &amp;&amp; parseInt(options.delay) > 3000) await wait(parseInt(options.delay));
       else await wait(10000);
    // if this is the first message
       if(!lastTweetID) {
        const tweet = await this.tweet(message, options.functionOptions);
        if(tweet.id) {
          lastTweetID = tweet.id;
        }
        threads.push(tweet);
        // if this is one of the messages after the first
       } else {
         const tweet = await this.reply(message, lastTweetID, options);
         if(tweet.id) {
          lastTweetID = tweet.id;
        }
        threads.push(tweet);
       }
           
       }
// return the threads
       return threads;
    }

       /**
   * Follow a user
   * @param {String} user - A user id or screen name
   * @param {Boolean} notifications - weather to Enable notifications for the target user
   * @returns {Promise&lt;User>}
   */
    async follow(user, notifications = true) {
      if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a User, got "${this.authenticationType}"`);
      if(!user) throw new Error('Please give me either a user id or a user screen name to follow');
      if(typeof user !== 'string' &amp;&amp; typeof user !== 'number' &amp;&amp; isNaN(user)) throw new Error(`User must be a userID (number) or a user scree name, received ${typeof user}`);
     // empty object, add values to this
      const body = {};
      // decide if a user id or a screen Name was provided
      if(isNaN(parseInt(user))) body.screen_name = user; 
      else body.user_id = user;
      // if notifs are enabled or not
      if(notifications) body.follow = true; 
      else body.follow = false; 
// send the request
      const request = await this.post('friendships/create', body);
      return new User(request, this);
    }

  /**
   * unFollows a user
   * @param {String} user - A user id or screen name
   * @returns {Promise&lt;User>}
   */
    async unfollow(user) {
      if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a User, got "${this.authenticationType}"`);
      if(typeof user !== 'string' &amp;&amp; typeof user !== 'number' &amp;&amp; isNaN(user)) throw new Error(`User must be a userID (number) or a user scree name, received ${typeof user}`);

       // empty object, add values to this
       const body = {};
       // decide if a user id or a screen Name was provided
       if(isNaN(parseInt(user))) body.screen_name = user; 
       else body.user_id = user;

       const request = await this.post('friendships/destroy', body);
       return new User(request, this);
    }

     /**
   * unFollows a user
   * @param {String} file - A url or a file path to image/media file
   * @param {Object} options - options for uploadMedia()
   * @param {String} options.altText - alt text for image
   * @param {String} options.message - optional message to post with the media
   * @returns {Promise&lt;tweet>}
   */
    async uploadMedia(file, options = {}) {
   if(!Func.isUrl(file) &amp;&amp; !Func.isPath(file)) throw new Error(`${file}, is not a valid path or a URl to a file`);
   const preparedFile = await Func.prepareFile(file);

   const body = {
    media_data: preparedFile,
  }; 

  const request = await this.post("media/upload", body);
  const altText = options.altText ? options.altText : 'tweets.js-img';
  const mediaIdStr = request.media_id_string;

  const meta_data_body = {
    media_id: mediaIdStr,
    alt_text: { text: altText },
  };

await this.post("media/metadata/create", meta_data_body);
const params = {
  media_ids: [mediaIdStr]
};

if(options.message) params.status = options.message;

const req = await this.post('statuses/update', params);

return new tweet(req, this);
}

    async verifyCredentials() {
        const req = await this.get('account/verify_credentials');
    
        return new User(req);
    }

     /**
   * Search users by a query
   * @param {String} query - query to search users of, ex: nodejs
   * @param {Object} options - request options
   * @param {String} options.page - Specifies the page of results to retrieve.
   * @param {String} options.count - The number of potential user results to retrieve per page. This value has a maximum of 20.
   * @param {string} options.includeEntities - The entities node will not be included in embedded Tweet objects when set to false
   * @returns {Promise&lt;User[]>}
   */
    async searchUsers(query, options = {}) {
      if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a User, got "${this.authenticationType}"`);
      if(!query) throw new Error('Cannot search for a empty query');
      if(typeof query !== 'string') throw new Error('query must be a string,');
   if(typeof options !== 'object') throw new Error('options must be a object');
   const parameters = {
     q: query,
     page: '1',
     count: '2',
   };
   if(options.page &amp;&amp; !isNaN(parseInt(options.page)) &amp;&amp; parseInt(options.page) &lt;= 10) parameters.page = options.page;
   if(options.count &amp;&amp; !isNaN(parseInt(options.count)) &amp;&amp; parseInt(options.count) &lt;= 20) parameters.count = options.count;
   if(options.includeEntities &amp;&amp; typeof options.includeEntities === 'boolean') parameters.include_entities = options.includeEntities;
// do request
   const request = await this.get('users/search', parameters);
// keep a array to push later
   const users = [];

   for(const user of request) {
      const constructedUserClass = new User(user, this);
      users.push(constructedUserClass);
   }

   return users;
    }
  
    
     /**
   * Get a users follower list
   * @param {String} user - A user id or screen name
   * @param {Object} options - Options for twitter api
   * @param {String} options.count - The number of user results to retrieve, max of 200
   * @param {Boolean} options.skip_status - Weather to not include status in the api response
   * @param {Boolean} options.include_user_entities - The user object entities node will not be included when set to false
   * @returns {Promise&lt;User[]>}
   */
   async getFollowers(user, options = {}) {
    if(typeof user !== 'string' &amp;&amp; typeof user !== 'number' &amp;&amp; isNaN(user)) throw new Error(`User must be a userID (number) or a user scree name (String), received ${typeof user}`);
    if(options &amp;&amp; typeof options !== 'object') throw new Error(`Options must be a object, ${typeof options}`);
   
    const parameters = {};

    if(isNaN(parseInt(user))) parameters.screen_name = user; 
    else parameters.user_id = user;

    if(options.count &amp;&amp; !isNaN(parseInt(options.count)) &amp;&amp; parseInt(options.count) &lt;= 200) parameters.count = options.count;
    if(options.skip_status &amp;&amp; options.skip_status == true) parameters.count = true;
    if(options.include_user_entities &amp;&amp; parameters.include_user_entities == false)  parameters.include_user_entities = false;

    const request = await this.get('followers/list', parameters);
    const users = [];
    if(request.users &amp;&amp; Array.isArray(request.users)) {
      for (user of request.users) {
       const constructedUserClass = new User(user, this);
       users.push(constructedUserClass);
      }
    }
    return users;
     }

     /**
   * gets A specific user from the api
   * @param {String} user - A user id or screen name
   * @returns {Promise&lt;User>}
   */
    async getUser(user) {
      if(typeof user !== 'string' &amp;&amp; typeof user !== 'number' &amp;&amp; isNaN(user)) throw new Error(`User must be a userID (number) or a user scree name (String), received ${typeof user}`);

      // empty object, add values to this
      const parameters = {};
      // decide if a user id or a screen Name was provided
      if(isNaN(parseInt(user))) parameters.screen_name = user; 
      else parameters.user_id = user;

      const request = await this.get('users/show', parameters);

      return new User(request, this);
    }

   /**
   * retweet a tweet
   * @param {String} tweetID - the id of the tweet
   * @returns {Promise&lt;tweet>} returns the tweet object for this tweet 
   */
    async retweet(tweetID) {
      if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a User, got "${this.authenticationType}"`);
      if(!tweetID) throw new Error('Tweet id must be present');
      if(typeof tweetID !== 'string') throw new Error(`tweetID must be a string, received ${typeof tweetID}`);

      const urlToPost = `statuses/retweet/${tweetID}`;

      const request = await this.post(urlToPost);
      return new tweet(request, this);
    }

    /**
   * clear the old pingTimeout and set a new timeout when a ping is received, if not auto reconnect
   * @fires client#reconnect
   * @private
   */
    _heartBeat() {
      clearTimeout(this.pingTimeout);

      this.pingTimeout = setTimeout(() => {
        this.emit('debug', '[CLIENT] => Heart-Beat timeout exceeded, reconnecting');
        this.reconnect();
      }, 40000);
    }
    /**
   * Start the stream
   * @param {Object} parameters - parameters for twitter api
   * @param {String} path - url to stream, defaults to what you set as stream url in client options
   * @fires client#ready
   * @fires client#ping
   * @fires client#tweet
   * @fires client#tweetDelete
   * @fires client#raw
   * @fires client#debug
   */
     start(parameters = {}, path = this.streamData.streamUrl) {
      if(this.authenticationType !== 'USER') throw new Error(`Auth type must be a User, got "${this.authenticationType}"`);
      if(!this.streamData.indefinite) throw new Error('Stream disabled');
      if(!parameters) throw new Error('Parameter must be present');
      if(this.stream) throw new Error('Stream already active');
      this.stream = new sm();
      this.stream.startedAt = Date.now();

      const Data = {
        url: `${Func.getUrl('stream')}/${path}${this.version == '1' ? '.json' : ''}`,
        method: 'POST',
      };

      if (parameters) Data.data = parameters;

      const headers = this._client.toHeader(
        this._client.authorize(Data, this._UserData),
      );
      headers['Content-Type'] = 'application/x-www-form-urlencoded';

    const streamRequest = fetch(Data.url, { method: 'POST', headers: headers , body: Func.percentEncode(querystring.stringify(parameters)), });
    
    
    streamRequest
      .then(response => {
        this.stream.destroy = () => response.body.destroy();

        if (response.ok) {
          this.stream.ready = true;
          this.stream.lastPing = Date.now();
          this.stream.parameters = parameters;
          if(this.streamData.reconnect == true) {
            this._heartBeat();
         }
         this.emit('debug', '[CLIENT] => Stream Connected successfully');
           /**
         * Ready event, fired when stream is connected
         * @event client#ready
         * @property {object} response - the raw response from the request
         * @property {streamManager} stream - the clients stream manager
         */
          this.emit('ready', response, this.stream);
        } else {
          response._headers = response.headers;
          this.emit('error', response);
          this.emit('debug', '[CLIENT] => Error occurred while connecting, disconnecting');
          return this.disconnect(false);
        }


    response.body.on('data', chunk => {
      this.emit('debug', '[CHUNk] => chunk received');
          let parsed;
          // try parsing the returned data
          try {
           parsed = this.stream._parse(chunk);
          } catch(err) {
            return this.emit('error', err);
          }

        

          if(!parsed) return;

          // a ping was received
          if(parsed === 'PING') {
            this.stream.lastPing = Date.now();
            if(this.streamData.reconnect == true) {
           this._heartBeat();
            }
             /**
         * received when the api sends a ping request
         * @event client#ping
         * @property {streamManager} stream - the clients stream manager
         */
              this.emit('debug', '[HEART_BEAT] => Heart-Beat received, resetting heart-beat timeout');
            return this.emit('ping', this.stream);
          }

          if (parsed.event !== undefined) {
            this.emit(parsed.event, parsed);
            return this.emit('raw', parsed, 'EVENT');
          }

          else if(parsed.text) {
          /**
         * When a new tweet is given by the stream api
         * @event client#tweet
         * @property {tweet} tweet - a tweet class
         */
            const tweetObj = new tweet(parsed, this);
            this.emit('tweet', tweetObj);
            return this.emit('raw', parsed, 'TWEET');
          }
          else if (parsed.delete) {
        /**
         * emitted when a tweet is deleted
         * @event client#tweetDelete
         * @property {deletedTweet} deletedTweet - the deletedTweet class
         */
        const deleted = new deletedTweet(parsed.delete, this);
            this.emit('tweetDelete', deleted);
            return this.emit('raw', parsed, 'TWEET_DELETE');
          }
          else if (parsed.warning) {
            /**
         * when a warning is given by the api
         * @event client#warning
         * @property {warning} warning - the parsed warning
         */
            this.emit('warning', parsed.warning);
            return this.emit('raw', parsed, 'WARN');
          }
          else {
              /**
         * every data received from the stream api
         * @event client#raw
         * @property {object} parsed - the parsed data
         * @property {String} type - the type of the event data
         */
            return this.emit('raw', parsed, 'UNKNOWN');
          }
        });

        response.body.on('error', error => this.emit('error', error));
        response.body.on('end', () => {
          this.emit('debug', '[STREAM] => Connection terminated');
          if(!this._options.streamData.autoReconnect) {
            clearTimeout(this.pingTimeout);
            this.emit('debug', '[CLIENT] => autoReconnect disabled, clearing heart-beat timeout');
          }
          this.emit('end', response);
        });
      }).catch(error => this.emit('error', error));

      return this;
  }

    /**
   * Disconnect the stream
   * @param {Boolean} removeListeners - Weather to remove all the event listeners attached to client/stream set to false if you want to make a manual reconnect logic and don't want to reregister the events
   */
  async disconnect(removeListeners = true) {
   if(!this.stream) throw new Error('No Stream active');
   if(removeListeners) {
    this.removeAllListeners(['ping']);
    this.removeAllListeners(['data']);
    this.removeAllListeners(['error']);
   }
    // destroy the stream
     this.stream.destroy();
     // set the stream to null
     this.stream = null;
     this.emit('destroy', true);
return null;
  }

    /**
   * Disconnects and reconnects the stream, does not remove the listeners
   * @param {Object} newParameters - The new parameters to start the stream with
   * @fires client#reconnect - When the client attempts to reconnect the stream, can be because of forced or due to client disconnection
   */
  async reconnect(newParameters = this.stream.parameters) {
    if(this.stream) await this.disconnect(false);
    if(!newParameters) throw new Error('Please provide new parameters for reconnect');
    if(!isNaN(parseInt(this._options.reconnectInterval)) &amp;&amp; parseInt(this._options.reconnectInterval) > 6000) {
      wait(parseInt(this._options.reconnectInterval));
    } else {
      wait(10000);
    }
          /**
         * When the client attempts to reconnect the stream, can be because of forced or due to client disconnection
         * @event client#reconnect
         */
   this.emit('debug', '[CLIENT] => Reconnect initiated');
    this.emit('reconnect');
    return this.start(newParameters);
  }
}

module.exports = client;</code></pre>
        </article>
    </section>





</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.7</a> on Mon May 31 2021 21:33:13 GMT+0530 (India Standard Time) using <a href="https://github.com/devsnowflake/jsdoc-skyceil">Skyceil Theme</a>
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>

</body>
</html>
